/**
* @license Apache-2.0
*
* Copyright (c) 2025 The Stdlib Authors.
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
*    http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*/

'use strict';

// MODULES //

// Include the function to be tested
var tape = require('tape');

// Replace `addon` with your actual function, for example:
var quantileFunction = require('./path_to_your_function'); // Adjust the path accordingly

// TESTS //

// Check that the main export is a function
tape('main export is a function', function test(t) {
    t.ok(true, __filename);
    t.strictEqual(typeof quantileFunction, 'function', 'main export is a function');
    t.end();
});

// Test that the function returns expected quantiles for valid inputs
tape('the function returns expected quantiles for valid inputs', function test(t) {
    var probabilities = [0.1, 0.25, 0.5, 0.75, 0.9];
    var sampleSizes = [3, 5, 7, 10];
    var expected;
    var actual;
    var p;
    var n;
    var i;
    var j;

    for (i = 0; i < sampleSizes.length; i++) {
        n = sampleSizes[i];
        for (j = 0; j < probabilities.length; j++) {
            p = probabilities[j];
            actual = quantileFunction(p, n);

            // Compute expected value based on known results or formula (placeholder logic here):
            expected /* Insert logic or precomputed values */;
            t.strictEqual(actual, expected, 'returns ' + expected + ' for p: ' + p + ', n: ' + n);
        }
    }
    t.end();
});

// Test that the function returns NaN for invalid inputs
tape('the function returns NaN for invalid inputs', function test(t) {
    var invalidProbabilities = [-0.1, 1.1, NaN];
    var invalidSampleSizes = [-5, 0, 3.5, NaN];
    var i;

    for (i = 0; i < invalidProbabilities.length; i++) {
        t.ok(isNaN(quantileFunction(invalidProbabilities[i], 5)), 'returns NaN for invalid probability: ' + invalidProbabilities[i]);
    }

    for (i = 0; i < invalidSampleSizes.length; i++) {
        t.ok(isNaN(quantileFunction(0.5, invalidSampleSizes[i])), 'returns NaN for invalid sample size: ' + invalidSampleSizes[i]);
    }
    t.end();
});
