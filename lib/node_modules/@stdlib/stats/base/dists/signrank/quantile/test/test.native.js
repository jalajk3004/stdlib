/**
* @license Apache-2.0
*
* Copyright (c) 2025 The Stdlib Authors.
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
*    http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*/

'use strict';

// MODULES //

var resolve = require('path').resolve;
var tape = require('tape');
var path = require('path');

// VARIABLES //
var quantile = require(resolve(__dirname, './../lib/native.js'));
var opts = {
	'skip': ( quantile instanceof Error )
};

// FIXTURES //

var data = require('./fixtures/r/data.json');

// TESTS //

tape('main export is a function',opts, function test(t) {
    t.ok(true, __filename);
    t.strictEqual(typeof quantile, 'function', 'main export is a function');
    t.end();
});

// Test that the function returns expected quantiles for valid inputs
tape('the function returns expected quantiles for valid inputs',opts, function test(t) {
    var probabilities = data.p;
    var sampleSizes = data.n;
    var expectedValues = data.expected;
    var actual, p, n;

    t.plan(probabilities.length);

    for (var i = 0; i < probabilities.length; i++) {
        p = probabilities[i];
        n = sampleSizes[i];
        actual = quantile(p, n);

        t.strictEqual(actual, expectedValues[i], 'returns ' + expectedValues[i] + ' for p: ' + p + ', n: ' + n);
    }
    t.end();
});

// Test that the function returns NaN for invalid inputs
tape('the function returns NaN for invalid inputs',opts, function test(t) {
    var invalidProbabilities = [-0.1, 1.1, NaN];
    var invalidSampleSizes = [-5, 0, 3.5, NaN];

    for (var i = 0; i < invalidProbabilities.length; i++) {
        t.ok(isNaN(quantile(invalidProbabilities[i], 5)), 'returns NaN for invalid probability: ' + invalidProbabilities[i]);
    }

    for (var j = 0; j < invalidSampleSizes.length; j++) {
        t.ok(isNaN(quantile(0.5, invalidSampleSizes[j])), 'returns NaN for invalid sample size: ' + invalidSampleSizes[j]);
    }
    t.end();
});
